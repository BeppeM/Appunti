
un automa a stati finiti ha un insieme di stati e un controllo che si muove da stato a stato in risposta a input esterni. Si ha una distinzione:
\begin{itemize}
\item \textbf{automi deterministici:} dove l'automa non può essere in più di uno stato per volta
\item \textbf{automi non deterministici:} dove l'automa può trovarsi in più stati contemporaneamente
\end{itemize}
\subsection{Automi deterministici}
Un automa a stati finiti deterministico (\textit{DFA}), un automa che dopo aver letto una qualunque sequenza di input si trova in un singolo stato. Il termine \textit{deterministico} concerne il fatto che per ogni input esiste un solo stato verso il quale l'automa passa dal suo stato corrente. Un automa a stati finiti deterministico consiste nelle seguenti parti:
\begin{itemize}
\item un insieme finito di stati, spesso indicato con $Q$
\item un insieme finito di simboli di input , spesso indicato con $\Sigma$
\item una funzione di transizione, che prende come argomento uno stato e un simbolo di input e restituisce uno stato. La funzione di transizione sarà indicata comunemente con $\delta$. Nella rappresentazione grafica informale di automi $\delta$ è rappresentata dagli archi tra gli stati e dalle etichette sugli archi. Se $q$ è uno stato e $a$ è un simbolo di input, $\delta(q,a)$ è lo stato $p$ tale che esiste un arco etichettato con $a$ da $q$ a $p^2$
\item uno stato iniziale, uno degli stati in $Q$
\item un insieme di stati finali, o accettanti , $F$. L'insieme $F$ è un sottoinsieme di $Q$
\end{itemize}
Nel complesso un DFA è rappresentato in maniera concisa con l'enumerazione dei suoi elementi, quindi con la quintupla:
$$A=(Q,\Sigma,\delta,q_0,F)$$
con $A$ nome del DFA, $Q$ insiem degli stati, $\Delta$ rappresentante i simboli di input, $\delta$ la sua funzione di transizione, $q_0$ il suo stato iniziale e $F$ l'insieme degli stati accettanti.\\
Vediamo come decidere se accettare o meno una stringa (sequenza di caratteri) in input mediante un DFA.\\
Ho una sequenza in input $a_1...a_n$. Parto dallo stato iniziale $q_0$, consultando la funzione di transizione $\delta$, per esempio  $\delta(q_0,a_1)=q_1$ e trovo lo stato in cui il DFA entra dopo aver letto $a_1$. Poi passo a $\delta(q_1,a_2)=q_2$ e così via, $\delta(q_{i-1},a_i)=q_i$ fino a ottenere $q_n$. Se $q_n$ è elemento di $F$ allora $a_1...a_n$ viene accettato, altrimenti viene rifiutato.
\begin{esempio}
specifico DFA che accetta tutte le strighe binarie in cui compare la sequenza 01:
$$L=\{w|w \mbox{ è della forma x01y, con x e y pari a 0 o 1} \}=\{01,11010,100011,...\}$$
o anche:
$$L=\{x01y| x,y\in\{0,1\}^* \}$$
abbiamo quindi:
$$\Sigma=\{0,1\}$$
ragioniamo sul fatto che $A$:
\begin{enumerate}
\item se ha "già visto" 01, accetterà qualsiasi input
\item pur non avendo ancora visto 01, l'input più recente è stato 0, cosicché se ora vede un 1 avrà visto 01
\item non ha ancora visto 01, ma l'input più recente è nullo (siamo all'inizio), in tal caso A non accetta finché non vede
uno 0 e subito dopo un 1
\end{enumerate} 
la terza condizione rappresenta lo stato iniziale. All'inizio bisogna vedere uno 0 e poi un 1. Ma se nello stato $q_0$ si vede per primo un 1 allora non abbiamo fatto alcun passo verso 01, e dunque dobbiamo permanere nello stato $q_0$, $\delta(q_0,1)=q_0$. D'altra parte se nello stato iniziale vedo 0 siamo nella seconda condizione, uso quindi $q_2$ per questa condizione, si avrà quindi $\delta(q_0,0)=q_2$. Vedo ora le transizoni di $q_2$, se vedo 0 ho che 0 è l'ultimo simbolo incontrato quindi uso nuovamente $q_2$, $\delta(q_2,0)=q_2$, in attesa di un 1. Se arriva 1 passo allo stato accertante $q_1$ corrispondente alla prima condizione, $\delta(q_2,1)=q_1$. Ora abbiamo incontrato 01 quindi può succedere qualsiasi cosa e dopo qualsiasi cosa accada potremo nuovamente aspettarci qualsiasi cosa, ovvero $\delta(q_1,0)=\delta(q_1,1)=q_1$. Si deduce quindi che:
$$Q=\{q_0,q_1,q_2\} \mbox{ e } F=\{q_1\}$$
quindi:
$$A=\{\{q_0,q_1,q_2\} ,\{0,1\}, \delta, q_0, \{q_1\} \}$$
con in totale le seguenti transizioni:
$$\delta(q_0,1)=q_0$$
$$\delta(q_0,0)=q_2$$
$$\delta(q_2,0)=q_2$$
$$\delta(q_2,1)=q_1$$
$$\delta(q_1,0)=q_1$$
$$\delta(q_1,1)=q_1$$
posso rappresentarle in maniera tabulare, con lo stato inizale indicato da $\to$ e quelli accettanti con $*$:
\begin{center}
\begin{tabular}{c|c|c}
$\delta$ & 0 & 1 \\
\hline
$\to\,q_0$ & $q_1$ & $q_0$\\
\hline
$*\,q_1$ & $q_1$ & $q_1$\\
\hline
$q_2$ & $q_2$ & $q_1$
\end{tabular}
\end{center}
o col diagramma di transizione:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_2) [right=of q_0] {$q_2$}; 
   \node[state, accepting] (q_1) [right=of q_2] {$q_1$}; 
   \path[->] 
   (q_0) edge  node {0} (q_2)
         edge [loop below] node {1} ()
   (q_2) edge  node  {1} (q_1)
         edge [loop below] node {0} ()
   (q_1) edge [loop below] node {0,1} ();
\end{tikzpicture}

\end{center}
\end{esempio}
\newpage
\begin{esempio}
Trovo automa per: $$L=\{w\in\{a,b\}^*|\mbox{ w che contiene un numero pari di b}\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial, accepting] (q_0) {$q_0$};
	\node[state] (q_1) [right=of q_0] {$q_1$};
	\path[->]
	(q_0) edge [bend left = 25] node {b} (q_1)
	      edge [loop below] node {a} ()
	(q_1) edge [bend left = 25] node {b} (q_0)
	      edge [loop below] node {a} ();
\end{tikzpicture}
\end{center}
ovvero se da $q_0$ vado a $q_1$ sono obbligato ab generare due $b$, dato che il nodo accettnate è $q_0$. In entrambi i nodi posso generare quante $a$ voglio.
\end{esempio}
\begin{esempio}
Trovo automa per: $$L=\{w\in\{a,b\}^*|\mbox{ w che contiene un numero dispari di b}\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_0$};
	\node[state, accepting] (q_1) [right=of q_0] {$q_1$};
	\path[->]
	(q_0) edge [bend left = 25] node {b} (q_1)
	      edge [loop below] node {a} ()
	(q_1) edge [bend left = 25] node {b} (q_0)
	      edge [loop below] node {a} ();
\end{tikzpicture}
\end{center}
ovvero se da $q_0$ vado a $q_1$ sono obbligato ab generare una sola $b$, dato che il nodo accettnate è $q_1$. In entrambi i nodi posso generare quante $a$ voglio e posso tornare da $q_1$ a $q_0$ per generare altre $b$.
\end{esempio}
\begin{esempio}
Trovo automa per: $$L=\{w\in\{0,1\}^*| w= 0^n1^m\}$$
vediamo i vari casi:
\begin{itemize}
\item $n,m\geq 0$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial, accepting] (q_0)   {$q_0$}; 
   \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; 
   \node[state] (q_E) [right=of q_1] {$q_E$}; 
   \path[->] 
   (q_0) edge  node {1} (q_1)
         edge [loop below] node {0} ()
   (q_1) edge  node  {} (q_E)
         edge [loop below] node {1} ()
   (q_E) edge [loop below] node {0,1} ();
\end{tikzpicture}
\end{center}
ovvero posso non generare nulla e uscire subito con $q_0$, generare solo un 1 e passare a $q_1$ e uscire oppure generare 0 e 1 a piacere con l'ultimo stato o generare 0 a piacere dal primo e 1 a piacere dal secondo.
\item $n\geq 0 \,\,m>0$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; 
   \node[state] (q_E) [right=of q_1] {$q_E$}; 
   \path[->] 
   (q_0) edge  node {1} (q_1)
         edge [loop below] node {0} ()
   (q_1) edge  node  {} (q_E)
         edge [loop below] node {1} ()
   (q_E) edge [loop below] node {0,1} ();
\end{tikzpicture}
\end{center}
ovvero come l'esempio sopra solo che non posso uscire in $q_0$ in quanto almeno un 1 deve essere per forza generato
\item $n> 0\,\, m\geq 0$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state, accepting] (q_1) [right=of q_0] {$q_1$}; 
   \node[state, accepting] (q_2) [right=of q_1] {$q_2$}; 
   \node[state] (q_E) [right=of q_2] {$q_E$}; 
   \path[->] 
   (q_0) edge  node {0} (q_1)
         edge [bend right] node {1} (q_E)
   (q_1) edge  node {1} (q_2)
         edge [loop above] node {0} ()
   (q_2) edge node {0} (q_E)
         edge [loop above] node {1} ()
   (q_E) edge [loop below] node {0,1} ();
\end{tikzpicture}
\end{center}
\textit{CHIARIRE}
\item $n,m>0$:
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [right=of q_0] {$q_1$}; 
   \node[state, accepting] (q_2) [right=of q_1] {$q_2$}; 
   \node[state] (q_E) [right=of q_2] {$q_E$}; 
   \path[->] 
   (q_0) edge  node {0} (q_1)
         edge [bend right] node {1} (q_E)
   (q_1) edge  node {1} (q_2)
         edge [loop above] node {0} ()
   (q_2) edge node {0} (q_E)
         edge [loop above] node {1} ()
   (q_E) edge [loop below] node {0,1} ();
\end{tikzpicture}
\end{center}
\textit{CHIARIRE}
\end{itemize}
\end{esempio}
\newpage
\begin{esempio}
Trovo automa per: $$L=\{w\in\{a,b\}^*|\mbox{ w che contiene un numero pari di a e dispari di b}\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_{pp}$};
	\node[state] (q_1) [right=of q_0] {$q_{dp}$};
	\node[state, accepting] (q_2) [below=of q_0] {$q_{pd}$};
	\node[state] (q_3) [right=of q_2] {$q_{dd}$};
	\path[->]
	(q_0) edge [bend left = 25] node {a} (q_1)
	      edge [bend right = 25] node [left] {b} (q_2)
	(q_1) edge [bend left = 25] node {a} (q_0)
	      edge [bend right = 25] node [left] {b} (q_3)
	(q_2) edge [bend right = 25] node [right] {b} (q_0)
	      edge [bend left = 25] node {a} (q_3)
	(q_3) edge [bend right = 25] node [right] {b} (q_1)
	      edge [bend left = 25] node {a} (q_2);
\end{tikzpicture}
\end{center}
\end{esempio}
\begin{esempio}
Trovo automa per: $$L=\{w\in\{a,b\}^*|\mbox{ w che contiene un numero pari di a seguito da uno dispari di b}\}$$
$$L=\{a^{2n}b^{2k+1}|j,k\geq 0\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_{0}$};
	\node[state, accepting] (q_1) [right=of q_0] {$q_{1}$};
	\node[state] (q_2) [below=of q_0] {$q_{2}$};
	\node[state] (q_3) [right=of q_2] {$q_S$};
	\node[state] (q_4) [right = of q_3] {$q_E$};
	\path[->]
	(q_0) edge [bend left = 25] node {b} (q_1)
	      edge [bend right = 25] node [left] {a} (q_2)
	(q_1) edge [bend left = 25] node {a} (q_4)
	      edge [bend right = 25] node [left] {b} (q_3)
	(q_2) edge [bend right = 25] node [below] {b} (q_4)
	      edge [bend right = 25] node [right] {a} (q_0)
	(q_3) edge [bend right = 25] node [right] {b} (q_1)
	      edge [bend left = 25] node {a} (q_4);
\end{tikzpicture}
\end{center}
ovvero in tabella:
\begin{center}
\begin{tabular}{c|c|c}
$\delta$ & a & b \\
\hline
$\to\,q_0$ & $q_1$ & $q_2$\\
\hline
$q_1$ & $q_0$ & $q_E$\\
\hline
$*\,q_2$ & $q_E$ & $q_3$\\
\hline
$q_S$ & $q_E$ & $q_2$\\
\hline
$q_E$ & $q_E$ & $q_E$
\end{tabular}
\end{center}
\end{esempio}
\begin{esempio}
Trovo automa per: $$L=\{a^{2k+1}b^{2h}|\, h,k\geq 0\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_{0}$};
	\node[state, accepting] (q_1) [right=of q_0] {$q_{1}$};
	\node[state] (q_3) [right=of q_1] {$q_{3}$};
	\node[state] (q_2) [below= of q_1] {$q_{2}$};
	\node[state, accepting] (q_4) [right = of q_2] {$q_4$};
	\node[state] (q_5) [right=of q_4] {$q_E$};
	\path[->]
	(q_0) edge  node [bend left = 25] {a} (q_1)
	(q_1) edge [bend left = 25] node {a} (q_2)
	      edge node [bend left= 25] {b} (q_3)
	(q_2) edge [bend left = 25] node [left] {a} (q_1)
	(q_3) edge [bend right = 25] node [left] {b} (q_4)
	(q_4) edge [bend right = 25] node {} (q_3);
\end{tikzpicture}
\end{center}
\end{esempio}
\begin{esempio}
Trovo automa per: $$L=\{a^{2n+1}b^{2k+1}|\, n,k\geq 0\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_{0}$};
	\node[state] (q_1) [right=of q_0] {$q_{1}$};
	\node[state, accepting] (q_3) [right=of q_1] {$q_{3}$};
	\node[state] (q_2) [below= of q_1] {$q_{2}$};
	\node[state] (q_4) [right = of q_2] {$q_4$};
	\node[state] (q_5) [right=of q_4] {$q_E$};
	\path[->]
	(q_0) edge  node [bend left = 25] {a} (q_1)
	(q_1) edge [bend left = 25] node {a} (q_2)
	      edge node [bend left= 25] {b} (q_3)
	(q_2) edge [bend left = 25] node [left] {a} (q_1)
	(q_3) edge [bend right = 25] node [left] {b} (q_4)
	(q_4) edge [bend right = 25] node [right] {b} (q_3);
\end{tikzpicture}
\end{center}
\end{esempio}
\begin{esempio}
Trovo automa per: $$L=\{x010y|\,x,y\in\{o,1\}^*\}$$
\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
	\node[state, initial] (q_0) {$q_{0}$};
	\node[state] (q_1) [right=of q_0] {$q_{1}$};
	\node[state] (q_2) [right=of q_1] {$q_{2}$};
	\node[state, accepting] (q_3) [right= of q_2] {$q_{3}$};
	\path[->]
	(q_0) edge  node {0} (q_1)
	      edge [loop above] node {1} ()
	(q_1) edge  node {1} (q_2)
	      edge [loop above] node {0} ()
	(q_2) edge  node {0} (q_3)
	(q_3) edge [loop below] node {0,1} ();
\end{tikzpicture}
\end{center}
\end{esempio}
\subsection{Automi non deterministici}
In sigla \textit{NFA} sono delle quintuple $A=(Q, \Sigma, \delta, q,F$ ma ora la delta prende uno stato e un simbolo e ci manda in un insieme di stati:
$$\delta:Q\times \Sigma\to 2^Q$$
delta è delta cappuccio
$$DFA:\,\,\, L(A)=\{w\in \Sigma^*|\,\delta(q_0,w)\in F\}$$
$$NFA:\,\,\, L(A)=\{w\in \Sigma^*|\,\delta(q_0,w)\cap F \neq \emptyset\}$$

\end{document}