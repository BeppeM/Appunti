\documentclass[a4paper,12pt, oneside]{book}

% \usepackage{fullpage}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{engrec}
\usepackage{rotating}
\usepackage{verbatim}
\usepackage[safe,extra]{tipa}
% \usepackage{showkeys}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{fontspec}
\usepackage{enumerate}
\usepackage{physics}
\usepackage{braket}
\usepackage{marginnote}
\usepackage{pgfplots}
\usepackage{cancel}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage{algorithm}
% \usepackage{algpseudocode}
\usepackage[cache=false]{minted}
\usepackage{mathtools}
\usepackage[noend]{algpseudocode}

\usepackage{tikz}\usetikzlibrary{er}\tikzset{multi  attribute /.style={attribute
    ,double  distance =1.5pt}}\tikzset{derived  attribute /.style={attribute
    ,dashed}}\tikzset{total /.style={double  distance =1.5pt}}\tikzset{every
  entity /.style={draw=orange , fill=orange!20}}\tikzset{every  attribute
  /.style={draw=MediumPurple1, fill=MediumPurple1!20}}\tikzset{every
  relationship /.style={draw=Chartreuse2,
    fill=Chartreuse2!20}}\newcommand{\key}[1]{\underline{#1}}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows,shapes,backgrounds,petri}
\tikzset{
  place/.style={
    circle,
    thick,
    draw=black,
    minimum size=6mm,
  },
  transition/.style={
    rectangle,
    thick,
    fill=black,
    minimum width=8mm,
    inner ysep=2pt
  },
  transitionv/.style={
    rectangle,
    thick,
    fill=black,
    minimum height=8mm,
    inner xsep=2pt
  }
} 
\usetikzlibrary{automata,positioning,chains,fit,shapes}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}
\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes
\usepackage[space]{grffile} % For spaces in paths
\usepackage{etoolbox} % For spaces in paths
\makeatletter % For spaces in paths
\patchcmd\Gread@eps{\@inputcheck#1 }{\@inputcheck"#1"\relax}{}{}
\makeatother

\title{Fondamenti Logico Matematici dell'Informatica}
\author{UniShare\\\\Davide Cozzi\\\href{https://t.me/dlcgold}{@dlcgold}}
\date{}

\pgfplotsset{compat=1.13}
\begin{document}
\maketitle

\definecolor{shadecolor}{gray}{0.80}
\setlist{leftmargin = 2cm}
\newtheorem{teorema}{Teorema}
\newtheorem{definizione}{Definizione}
\newtheorem{esempio}{Esempio}
\newtheorem{corollario}{Corollario}
\newtheorem{lemma}{Lemma}
\newtheorem{osservazione}{Osservazione}
\newtheorem{nota}{Nota}
\newtheorem{esercizio}{Esercizio}
\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}
\tableofcontents
\renewcommand{\chaptermark}[1]{%
  \markboth{\chaptername
    \ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\MYhref}[3][blue]{\href{#2}{\color{#1}{#3}}}%
\chapter{Introduzione}
\textbf{Questi appunti sono presi a lezione. Per quanto sia stata fatta
  una revisione è altamente probabile (praticamente certo) che possano
  contenere errori, sia di stampa che di vero e proprio contenuto. Per
  eventuali proposte di correzione effettuare una pull request. Link: }
\url{https://github.com/dlcgold/Appunti}.\\
\chapter{Dimostrazioni = Algoritmi}
Parliamo in primis del \textbf{paradigma dimostrazioni = algoritmi}.\\
Prendiamo come \textit{linguaggio di specifica} un \textbf{linguaggio
  del prim'ordine con identità}.
\begin{shaded}
  Si riportano alcune definizioni utili in \textit{logica matematica} tratte da
  Wikipedia: 
  \begin{definizione}
    Definiamo \textbf{linguaggio del primo ordine} come un linguaggio formale
    che serve per gestire meccanicamente enunciati e ragionamenti che
    coinvolgono i connettivi logici, le relazioni e i quantificatori $\forall$ e
    $\exists$.\\
    Si ha che ``del primo ordine'' ndica che c'è un insieme di riferimento e i
    quantificatori possano riguardare solo gli elementi di tale insieme e non i
    sottoinsiemi (posso dire ``per tutti gli elementi'' ma non ``per tutti i
    sottoinsiemi''). Tale linguaggio è caratterizzato da:
    \begin{itemize}
      \item un \textbf{alfabeto di simboli} per variabili, costanti, predicati,
      funzioni, connettivi, quantificatori o punteggiatura 
      \item un \textbf{insieme di termini} per denotare gli elementi
      dell'insieme in analisi
      \item un \textbf{insieme di formule ben formate (\textit{FBF})} ovvero un
      insieme di stringhe composte di simboli dell'alfabeto che vengono
      considerate sintatticamente corrette 
    \end{itemize}
  \end{definizione}
  \begin{definizione}
    Definiamo \textbf{sistema assiomatico} come un insieme di assiomi che
    possono essere usati per dimostrare teoremi. Una teoria matematica consiste
    quindi in una assiomatica e tutti i teoremi che ne derivano.  
  \end{definizione}
  \begin{definizione}
    Definiamo un sistema formale come una formalizzazione rigorosa e completa
    della nozione di sistema assiomatico costituito da:
    \begin{itemize}
      \item un alfabeto
      \item una grammatica che specifica quali sequenze finite dei simboli
      dell'alfabeto corrispondono ad una FBF. La grammatica deve essere
      ricorsiva, nel senso che deve esistere un algoritmo per decidere se una
      sequenza di simboli è o meno una formula ben formata 
      \item un sottoinsieme delle FBF che sono gli assiomi. L'insieme degli
      assiomi è ricorsivo
      \item le regole di inferenze che associano formule ben formate ad n-uple
      di formule ben formate
    \end{itemize}
  \end{definizione}
  \begin{definizione}
    Definiamo gli \textbf{assiomi di Peano} come un gruppo di assiomi ideati al
    fine di definire assiomaticamente l'insieme dei numeri naturali:
    \begin{itemize}
      \item esiste un numero naturale: 0 (alternativamente 1 se si vuole escludere
      0):
      \[0/1\in \mathbb{N}\]
      \item ogni naturale ha un naturale come successore. Ho quindi una funzione
      ``successore'' tale che:
      \[S:\mathbb{N}\to\mathbb{N}\]
      \item numeri diversi hanno successori diversi, ovvero:
      \[x\neq y\to S(x)\neq S(y)\]
      \item 0 (o alternativamente 1) non è il successore di alcun naturale,
      ovvero:
      \[S(x)\neq 0, \forall x\in \mathbb{N}\]
      \item ogni sottoinsieme di numeri naturali che contenga lo zero e il
      successore di ogni proprio elemento coincide con l'intero insieme dei
      numeri 
      naturali. Ovvero dato $U\subseteq \mathbb{N}$ tale che:
      \begin{itemize}
        \item $0\in U$
        \item $x\in U\to S(x)\in U$
      \end{itemize}
      allora:
      \[U=\mathbb{N}\]
      Tale assioma è detto \textbf{assioma dell'induzione} o \textbf{principio di
        induzione} 
    \end{itemize}
  \end{definizione}
  \begin{definizione}
    In una teoria del primo ordine si chiama \textbf{chiusura universale} di una
    formula ben formata $A(x_1,\ldots,x_n)$, con $x_1,\ldots,x_n$ variabili
    libere, la formula:
    \[\forall x_1\forall x_2\forall x_n\,\,A(x_1,\ldots,x_n)\]
    ottenuta premettendo un quantificatore universale su ogni variabile libera. 
  \end{definizione}
  \begin{definizione}
    Definiamo, in logica matematica, \textbf{aritmetica di Peano (\textit{PA})}
    come una teoria del primo 
    ordine che ha come assiomi propri una versione degli \textbf{assiomi di
      Peano} 
    espressi nel linguaggio del primo ordine. Si ha quindi che il linguaggio di
    PA 
    è il linguaggio dell'aritmetica del primo ordine con i seguenti simboli:
    \begin{itemize}
      \item vari simboli per le variabili: $x$, $y$, $z$, $x_1$ etc$\ldots$
      \item costanti individuali: $0$ etc$\ldots$
      \item simboli per funzioni unarie: $S$
      \item simboli per funzioni binarie $+$, $\times$ ($+(x,y)$ si indica anche
      con $x+y$ e analogamente si fa per $\times$)
      \item simboli per relazioni unarie: $=$
      \item simboli per connettivi logici, quantificatori e parentesi
    \end{itemize}
    Gli assiomi di PA sono costituiti da:
    \begin{itemize}
      \item gli assiomi logici
      \item gli assiomi per l'uguaglianza
      \item i seguenti assiomi propri (che ``traducono'' nella logica di Peano
      gli assiomi di Peano):
      \begin{itemize}
        \item $\forall x\neg(S(x)=0)$
        \item $\forall x\forall y(S(x)=S(y)\to x=y)$
        \item $\forall x(x+0=x)$
        \item $\forall x\forall y(x+S(y)=S(x+y))$
        \item $\forall x(x\times 0 =0)$
        \item $\forall x\forall y(x\times S(y)=(x\times y)+x)$
      \end{itemize}
    \end{itemize}
    Agli assiomi propri si aggiunge anche il seguente assioma proprio:
    {\footnotesize{\[(\phi(0,x_1,\ldots,x_n)\land(\forall
      x(\phi(x,x_1,\ldots,x_n)\to\phi(S(x),x_1,\ldots,x_n))\to\forall 
      x\phi(x,x_1,\ldots,x_n)\]}}
    per ogni FBF $\phi(x,x_1,\ldots,x_n)$ di cui
    $x,x_1,\ldots,x_n$ sono variabili libere. Questo è uno schema di assiomi
    detto \textbf{schema di induzione} e si ha un assioma per ogni FBF
    $\phi$ 
  \end{definizione}
  \begin{definizione}
    Definiamo, in logica classica, il \textbf{principio del terzo escluso} che
    stabilisce che una proposizione e la sua negazione hanno valore opposto, non
    avendo una ``terza opzione''. In logica classica è una \textbf{tautologia}.
  \end{definizione}
  \begin{definizione}
    Un termine è un \textbf{termine chiuso} sse non contiene delle variabili
    individuali.  
  \end{definizione}
  \begin{definizione}
    Una \textbf{formula chiusa} è una formula costruita nel linguaggio dei
    predicati in cui o non compaiono variabili o tutte le variabili presenti
    sono vincolate a un quantificatore e sono dunque variabili legate. 
  \end{definizione}
\end{shaded}
\begin{esempio}
  Vediamo qualche esempio:
  \[\forall x,y\in\mathbb{N},\,\,\exists z\in\mathbb{N}\mbox{ t.c. }
    mcd(x,y,z)\]
  ovvero $z$ è l'\textit{mcd} di $x$ e $y$.\\
  Un altro esempio:
  \[\forall x\in \mathbb{N},\,\,\exists y\in \mathbb{N}\mbox{ t.c. }
    fatt(x,y)\]
  ovvero $y$ è il fattoriale di $z$.
\end{esempio}
Formule come quelle dell'esempio possono essere lette come \textbf{specifiche
  del problema di trovare un algoritmo totalmente corretto} che calcoli il
risultato di tale problema per ogni input valido. Questa lettura non è implicita
nella logica classica, dove non è richiesto di stabilire come viene prodotto il
risultato. Si ha quindi a che fare con una lettura di un problema algoritmico di
interesse per un informatico.\\
Le \textbf{dimostrazioni} di questa tipologia di formule, nell'ambito
dell'\textbf{aritmetica di Peano (\textit{PA})}, sono quindi interpretabili come
gli algoritmi che calcolano le funzioni specificate. \\
Come \textit{vantaggi} di questa ``atteggiamento'' si ha che:
\begin{itemize}
  \item l'attenzione si concentra su costruire la dimostrazione, sui passi
  dimostrativi, e non sulla stesura del codice
  \item i passi elementari della dimostrazione sono automatici
  \item la correttezza della dimostrazione è verificabile in modo automatico
  \item l'estrazione/sintesi dell'algoritmo dalla dimostrazione è diretta. Una
  volta che si ha la dimostrazione corretta si può estrarre direttamente
  l'algoritmo. Tale algoritmo è totalmente corretto rispetto alla specifica
\end{itemize}
La difficoltà si trasferisce dall'ambito convenzionale della programmazione e
codifica dell'algoritmo in se alla costruzione dimostrazione e dei passi
dimostrativi.\\
Si hanno quindi anche degli \textit{svantaggi}, abbastanza problematici:
\begin{itemize}
  \item l'algoritmo ottenuto non è ottimale rispetto al problema. Rispetto a
  questo bisognerebbe capire come incorporare ``più semantica'' del problema da
  risolvere nella dimostrazione stessa
  \item il formalismo e il linguaggio delle dimostrazioni sono ``lontani'' da
  quelli usati usualmente nella pratica informatica
\end{itemize}
\textbf{Non tutte le dimostrazioni sono direttamente interpretabili come
  algoritmi}. Per vedere questa cosa prendiamo un esempio famoso di formula da
dimostrare in analisi.
\begin{esempio}[esempio di Troelstra]
  Esistono due numeri irrazionali $n$ e $m$ tali che $n^m$ è razionale. In
  termini di formula del primo ordine si ha quindi:
  \[\exists n,m\in\{\mathbb{R}/\mathbb{Q}\}\mbox{ t.c. }n^m\in\mathbb{Q}\]
  Cerchiamo di capire se:
  \[\sqrt{2}^{\sqrt{2}}\in \mathbb{Q}\mbox{ o }\sqrt{2}^{\sqrt{2}}\not\in
    \mathbb{Q}\]
  Vediamo quindi i due casi (sono solo due per il principio del terzo escluso):
  \begin{enumerate}
    \item assumo $\sqrt{2}^{\sqrt{2}}\in \mathbb{Q}$ e pongo $n=m=\sqrt{2}$
    avendo trovato due numeri irrazionali $n$ e $m$ tali per cui
    $n^m\in\mathbb{Q}$ 
    \item assumo $\sqrt{2}^{\sqrt{2}}\not\in \mathbb{Q}$ e pongo
    $n=\sqrt{2}^{\sqrt{2}}$ e $m=\sqrt{2}$. Ne segue che:
    \[n^m=\left(\sqrt{2}^{\sqrt{2}}\right)^{\sqrt{2}}=(\sqrt{2})^2=2\in\mathbb{Q}\] 
    e quindi ho due numeri irrazionali $n$ e $m$ tali per cui $n^m\in\mathbb{Q}$
  \end{enumerate}
  Non possiamo essere soddisfatti di questa dimostrazione. Non veniamo a
  conoscenza, tramite la dimostrazione, che $\sqrt{2}^{\sqrt{2}}$ sia o meno
  razionale. Non possiamo capirlo in quanto assumo il terzo escluso e quindi non
  so quale dei due casi sia valido, non abbiamo un ``esiste'' costruttivo
  ($\exists n,m\in \{\mathbb{R}/\mathbb{Q}\}$) in quanto non sappiamo se
  $\sqrt{2}^{\sqrt{2}}$ è razionale o meno. Nonostante ciò al dimostrazione sta
  perfettamente ``in piedi'' ma non esibisce $n$ e $m$ in quanto non determina
  se $\sqrt{2}^{\sqrt{2}}\in\mathbb{Q}$.
\end{esempio}
Quanto successo nell'esempio di Troelstra non può succedere in un
\textbf{sistema costruttivo}.
\begin{definizione}
  Definiamo \textbf{sistema costruttivo} un sistema dove si hanno come
  \textit{requisiti minimali}: 
\begin{itemize}
  \item $S\vdash A\lor B\to S\vdash A\mbox{ oppure } S\vdash B$ quindi se
  nel sistema dimostro $A\lor B$ allora nel sistema dimostro $A$ o dimostro $B$,
  con $A$ e $B$ formule chiuse. Questa è la \textbf{disjunction property
    (\textit{DP})}  
  \item $S\vdash\exists xA(x)\to S\vdash A(t)$ quindi se ho dimostrato un
  esistenziale allora deve esistere un termine chiuso $t$ per cui dimostro
  $A(t)$ nel sistema. Questa è la \textbf{explicitly definibility property
    (\textit{EDP})}, detta anche \textbf{existence/witness property}
\end{itemize}
\end{definizione}
La logica classica quindi \textbf{non è un sistema costruttivo} perché in logica
classica riesco sempre a dimostrare $A\lor\neg A$ mentre nell'esempio di
Troelstra si nota come non si possa dimostrare né $A$ né $\neg A$. Quindi da una
dimostrazione classica di $A\lor\neg A$ io non tiro fuori una dimostrazione
classica di $A$ oppure una dimostrazione classica di $\neg A$ quindi non vale la
DP. Inoltre non vale nemmeno la EDP, ho dimostrato l'esistenza di $n$ e $m$ (che
sono termini chiusi) ma non ho trovato se vale la proprietà che siano
irrazionali. La logica classica quindi non è una logica costruttiva.
\section{Interpretazione BHK}
Passiamo quindi ad una semantica informale che per ogni costante logica associa
una condizione per la sua \textit{costruibilità}. Questa è
\textbf{l'interpretazione Brouwer-Heyting-Kreisel (\textit{BHK})}.
\begin{definizione}
  Presa una costruzione $\pi$ per questa semantica proposizionale si ha che:
  \begin{itemize}
    \item $\pi(A\land B)=\pi'(A)\mbox{ e } \pi''(B)$ ovvero una costruzione di
    $A\land B$ e uguale ad un'altra costruzione di $A$ \textbf{e} un'altra
    ancora di $B$ 
    \item $\pi(A\lor B)=\pi'(A)\mbox{ o } \pi''(B)$ ovvero una costruzione di
    $A\lor B$ e uguale ad un'altra costruzione di $A$ \textbf{o} un'altra ancora
    di $B$
    \item $\pi(A\to B)$ è una funzione  (o un funzionale, ovvero un
    insieme di funzioni) $f$ che associa ad ogni
    costruzione $\pi'(A)$ una costruzione $\pi''(B)$ tale che
    $\pi''=f(\pi')$. Quindi $f$ associa costruzioni di $A$ a costruzioni di $B$
    \item $\pi(\neg A)$ è una costruzione $\pi'$ di $A\to\bot$
  \end{itemize}
  Lato semantica predicativa si ha che, dato un dominio $D$ per la variabile
  $x$: 
  \begin{itemize}
    \item $\pi(\exists xA(x))=\langle c,\pi'\rangle|\,c\in D\mbox{ e
    }\pi'(A(c))$ quindi è uguale ad una coppia $=\langle c,\pi'\rangle$ tale che
    $c$ appartiene al dominio e $\pi'$ è una costruzione effettiva di $A(c)$
    \item $\pi(\forall xA(x))=$ è una funzione $f$ che associa ad ogni elemento
    $c\in D$ una costruzione $\pi'(A(c))$ tale che $\pi'=f(c)$
  \end{itemize}
\end{definizione}
Questa semantica ``naive'' ha alcune problematiche/aporie:
\begin{itemize}
  \item la BHK non specifica la costruzione di una formula atomica
  \item la BHK non dimostra il falso infatti nella costruzione di $\neg$
  associamo la costruzione del $\neg A$ a quella dell'implicazione, che è una
  costruzione che associa costruzioni di $A$ e costruzioni di $B$ e quindi
  nessuna costruzione potrebbe avere il falso (???)
\end{itemize}
Bisognerà quindi chiarire alcune restrizioni dell'interpretazione BHK.\\
Si hanno varie semantiche per il costruttivismo che hanno ``precisato'' la BHK:
\begin{itemize}
  \item la semantica della\textbf{realizzabilità ricorsiva} di Kleene
  \item la semantica dell'\textbf{interpretazione dialettica} di G\"{o}del
  \item la semantica delle \textbf{prove possibili} di Prawitz
  \item la semantica dei \textbf{problemi finiti} di Medvedev
\end{itemize}
Queste 4 semantiche sono coerenti con la BHK e quindi sono \textbf{semantiche
  del costruttivismo}.\\
Passiamo ora ad una definizione formale.
\begin{definizione}
  Definiamo come \textbf{sistema costruttivo} un sistema $S$:
  \[S=T+L\]
  dove:
  \begin{itemize}
    \item $T$ è una teoria con assiomi di forma particolare
    \item $L$ è una logica intuizionistica, che prendiamo come punto di partenza
    per il costruttivismo, con le sue estensioni
  \end{itemize}
  Non sempre comunque date $T$ e $L$ si ha che $S$ è un sistema costruttivo.
\end{definizione}
Un esempio di sistema costruttivo è dato dall'\textbf{aritmetica
  intuizionistica}, ovvero la PA interpretata all'interno della logica
intuizionistica. Altri esempi sono le \textbf{teorie con assiomi di Harrop},
teorie con assiomi $\forall\exists$ con matrice positiva priva di quantificatori
e con minimo modello di Herbrandt etc$\ldots$\\ 
Le clausole di Horn usate i Prolog hanno un
modello minimo di Herbrandt e hanno  assiomi $\forall\exists$ con matrice
positiva priva di quantificatori dove $\exists$ viene eliminato attraverso
skolemizzazione e il $\forall$ è implicito nelle regole del programma in quanto
tutte le $X$, $Y$ etc$\ldots$ si intendono quantificati universalmente.\\
Quindi la parte assiomatica di una teoria non basta a rendere costruttivo il
sistema anche se la logica è costruttiva. Tuttavia se si restringono le
assiomatizzazioni con formule del primo ordine di tipo particolare si possono
ottenere sistemi costruttivi in cui vale come minimo la \textit{DP} e la
\textit{EDP}.
\section{Deduzione naturale}
Vediamo un accenno della \textbf{deduzione naturale} ovvero di un
\textbf{calcolo diretto} (quindi differente dal calcolo indiretto dei
tableaux). Nella deduzione naturale si ha per ogni connettivo una \textbf{regola
di introduzione} $i$ e una \textbf{regola di eliminazione} $e$. Ad esempio se ho
$A$ e $B$ come premesse posso introdurre l'and con la regola d:i introduzione
dell'and: 
\[\frac{A\,\,\,\,B}{A\land B}i\land\]
Se invece ho $A\land B$ come premessa posso usare la regola di eliminazione
dell'and, producendo:
\[\frac{A\land B}{A}e\land\mbox{ oppure }\frac{A\land B}{B}e\land\]
Avendo quindi due regole di eliminazione per l'and.\\
Passiamo all'or. Ho due regole di introduzione:
\[\frac{A}{A\lor B}i\lor\mbox{ oppure }\frac{B}{A\lor B}i\lor\]
L'eliminazione della or è complessa e verrà trattata più avanti ma è della
forma:
\[\frac{A\lor B\,\,\,\,C\,\,\,\,C}{C}e\lor\]
Dove si ha che se se ho $A\lor B$ come premessa e assumendo $A$ ho $C$ ma anche
assumendo $B$ ho $C$ posso eliminare l'or e ottenere $C$.\\
Passiamo all'implicazione. Se ho come assunzione $A$ e da $B$ riesco a
dimostrare $B$ allora posso introdurre l'implicazione:
\[\frac{\stackrel{\stackrel{[A]}{\cdots}}{B}}{A\to B}i\to\]
Per l'eliminazione ho che, tramite \textbf{modus ponens}:
\[\frac{A\to B\,\,\,\,A}{B}e\to\]
Abbiamo poi la \textbf{regola del falso} che dice che dal falso segue qualsiasi
cosa: 
\[\frac{\bot}{B}\bot\]
e la regola dell'eliminazione della negazione che dice che se assumo $\neg A$ e
ottengo il falso significa che si è ottenuta una contraddizione e quindi elimino
il $\neg$:
\[\frac{\stackrel{[\neg A]}{\bot}}{A}e\neg\]
Passiamo al $\forall$. Se ho dedotto $A(p)$ per $p$ generico posso introdurre il
$\forall$:
\[\frac{A(p)}{\forall xA(x)}i\forall\]
Se ho come assunzione $\forall xA(x)$ posso dedurre un qualsiasi $A(t)$:
\[\frac{\forall xA(x)}{A(t)}e\forall\]
Possiamo fare l'equivalente per l'$\exists$, dove se esiste $A(t)$ posso dedurre
l'esistenza di un certo $x$ per cui vale $A(x)$:
\[\frac{A(t)}{\exists xA(x)}i\exists\]
L'eliminazione dell'esiste è complessa e verrà trattata più avanti ma è della
forma:
\[\frac{\exists xA(x)\,\,\,\,\stackrel{[A(p)]}{C}}{C}e\exists\]
Dove assumendo $\exists xA(x)$, assumendo $A(p)$ con $p$ generico e riuscendo ad
ottenere $C$ da quest'ultima assunzione con una serie di restrizioni posso
ottenere $C$ eliminando $\exists$.\\
Una dimostrazione in deduzione naturale è modulare alle logiche si vogliono
usare:
\begin{itemize}
  \item nelle dimostrazioni in logica classica utilizzo tutte le regole della
  deduzione naturale appena introdotte
  \item nelle dimostrazioni in logica intuizionistica non devo usare la regola
  di eliminazione della negazione
  \item  nelle dimostrazioni in logica minimale non devo usare la regola
  di eliminazione della negazione e nemmeno la regola che dal falso segue
  qualsiasi cosa
\end{itemize}
Possiamo quindi caratterizzare queste tre logiche e nelle ultime due, quella
intuizionistica e quella minimale, si può dimostrare che valgono DP e EDP mentre
non posso dire lo 
stesso per la logica classica. Si ha inoltre che:
\[\mbox{logica minimale}\subseteq\mbox{logica
    intuizionistica}\subseteq\mbox{logica classica}\]
Discorso diverso vale per le teorie, ovvero per i sistemi, dove
l'assiomatizzazione può fare la differenza portando anche fuori dalla
costruttività (se ad esempio assumo come assioma che $\forall xA(x)\lor\neg
A(x)$ e gli aggiungo la logica intuizionistica ottengo la logica classica che
non è costruttiva).\\
Una teoria specifica è l'aritmetica di Peano dove si hanno i seguenti assiomi:
\begin{itemize}
  \item $\forall x\neg(S(x)=0)$
  \item $\forall x\forall y(S(x)=S(y)\to x=y)$
  \item $\forall x(x+0=x)$
  \item $\forall x\forall y(x+S(y)=S(x+y))$
  \item $\forall x(x\times 0 =0)$
  \item $\forall x\forall y(x\times S(y)=(x\times y)+x)$
\end{itemize}
Dove si ha la regola d'identità che in realtà sono due, ovvero $id1$ e $id2$:
\[\frac{}{x=x}id1\mbox{ e } \frac{x=y\,\,\,\,A(x)}{A(y)}id2\]
Dove si ha anche il principio/regola d'induzione:
\[\frac{A(0)\,\,\,\,\stackrel{\stackrel{[A(j)]}{\cdots}}{A(S(j))}}{A(t)}ind\]
Dove se dimostro $A(0)$ e assunto $A(j)$ dimostro il successore di $A(j)$ allora
posso dedurre $A(t),\forall t$.
\begin{esempio}
  Vediamo ora un esempio con degli assiomi specifici, costruttivi:
  \begin{itemize}
    \item $pari(0)$
    \item $\forall x(pari(x)\to \neg pari(S(x)))$
    \item $\forall x(\neg pari(x)\to pari(S(x)))$
  \end{itemize}
  Quindi si ha che se $x$ è apri non lo è il successore e se $x$ non è pari lo è
  il successore. Assumiamo inoltre che 0 sia pari.\\
  \textup{Scritta così potrebbe essere riscritta ``1:1'' in Prolog.}\\
  Cerchiamo quindi din dimostrare che che:
  \[\forall x(pari(x)\lor \neg pari(x))\]
  che si può pensare si un terzo escluso e quindi valga sempre. Questa formula,
  a 
  livello di specifica, va letta come una funzione ``per ogni numero naturale
  costruisce $pari(x)$ o $\neg pari(x)$'' quindi costruisce o la parte sinistra
  o 
  la parte destra. Quindi la formula i può leggere come la specifica di
  algoritmo 
  che per ogni naturale mi dice se vale la parte sinistra o la parte destra
  dell'or e quindi è un algoritmo di decisione effettivo che per ogni naturale
  ti 
  dice se è pari o non è pari. Questa è un'interpretazione diversa da quella
  classica. \\
  Posso quindi fare una dimostrazione per induzione.\\
  Il \textbf{caso base} è, chiamando $pari$ $p$, assunto per assioma $p(0)$ e
  usando l'introduzione dell'or:
  \[\frac{p(0)}{p(0)\lor \neg p(0)}i\lor\]
  Passo al \textbf{caso passo}.\\
  Assumo per ipotesi induttiva $p(j)\lor \neg p(j)$ e assumiamo $\forall
  x(p(x)\lor \neg p(S(x)))$ che è un altro degli assiomi. Procedo eliminando il
  $\forall$:
  \[\frac{\forall x(p(x)\lor \neg p(S(x)))}{p(j),p(j)\to\neg
      p(S(j))}e\forall\]
  procedo quindi eliminando l'implicazione:
  \[\frac{p(j),p(j)\to\neg
      p(S(j))}{\neg p(S(j))}e\to\]
  e continuo inserendo l'or:
  \[\frac{\neg p(S(j))}{p(S(j))\lor\neg p(S(j))}i\lor\]
  Analogamente faccio per l'altro assioma $\forall x(\neg p(x)\lor p(S(x)))$:
  \[\frac{\forall x(\neg p(S(x) )\lor  p(S(x)))}{\neg p(j),\neg p(j)\to
      p(S(j))}e\forall\]
  \[\frac{\neg p(j),\neg p(j)\to
      p(S(j))}{p(S(j))}e\to\]
  \[\frac{p(S(j))}{p(S(j))\lor\neg p(S(j))}i\lor\]
  Partendo quindi da $p(j)\lor \neg p(j)$ posso fare l'eliminazione dell'or
  ottenendo il \textbf{caso passo}:
  \[\frac{p(j)\lor\neg p(j)}{p(S(j))\lor\neg p(S(j))}e\lor\]
  e quindi posso concludere il passo induttivo:
  \[\frac{p(0)\lor \neg p(0)\,\,\,\,p(S(j))\lor\neg p(S(j))}{\forall
      x(p(x)\lor \neg p(x))}ind\]
  concludendo al dimostrazione costruttiva.\\
  Posso quindi dire che, essendo 0 pari, 1 è dispari e quindi 2 è pari, 3
  dispari etc$\ldots$ in pratica è un ciclo che parte dal caso base e poi decide
  per qualsiasi numero naturale. Possiamo quindi estrarre un algoritmo iterativo
  (potrei anche estrarne uno ricorsivo) da questa dimostrazione. Tale algoritmo
  è visualizzabile nell'implementazione C nel listing \ref{lst:pari}.
\end{esempio}
\begin{listing}
  \inputminted{c}{``code/pari.c''}
  \label{lst:pari}
  \caption{Codice C dell'algoritmo di calcolo pari creato dalla dimostrazione}
\end{listing}
Come detto algoritmi così sintetizzati non sono algoritmi ottimali e l'esempio
del pari o dispari è evidente. Normalmente si avrebbe infatti:
\begin{listing}[H]
  \inputminted{c}{``code/pariopt.c''}
  \label{lst:pari2}
  \caption{Codice C dell'algoritmo di calcolo pari ottimale}
\end{listing}
E quindi si ha un limite nella costruzione dell'algoritmo anche se il primo
sappiamo essere corretto (avendo applicato la deduzione naturale e l'induzione,
ho la garanzia che in quella assiomatizzazione il programma sia totalmente
corretto) mentre di quest'ultimo dovremmo dimostrare la correttezza. Nel primo
programma la componente funzionale della dimostrazione è data dalle varie
funzioni che si richiamano. L'algoritmo per ogni istanza calcola se vale la
parte sinistra o destra della disgiunzione in modo uniforme. Le funzioni si
deducono automaticamente dalla prova costruttiva. Niente di tutto ciò è
asseribile sull'algoritmo ottimo.\\ 
Parlando invece di Prolog avrei una situazione diversa. In Prolog ogni
computazione è un'\textit{istanza di dimostrazione} che varia di caso in caso e
quindi non si ha una dimostrazione generale. Possiamo dire che un programma
Prolog non rappresenta l'algoritmo che risolve il problema specificato per ogni
dato di input. Si ha quindi un diverso modello di calcolo/computazione.
\chapter{Logica Proposizionale Intuizionistica}
La \textbf{logica proposizionale intuizionistica} è il primo paradigma che
trattiamo di \textbf{logica costruttiva}, dove appunto valgono la \textbf{DP} e
la \textbf{EDP}, che sono i due requisiti minimali per dire che una logica è
costruttiva. L'intuizionismo è il paradigma minimale di logica costruttiva.
\section{Intuizionismo Proposizionale}
Iniziamo a parlare dell'intuizionismo proposizionale e già a livello di
linguaggio si ha una differenza tra la logica classica e quella
intuizionistica.\\
Il linguaggio della logica proposizione intuizionistica comprende i seguenti
\textit{simboli}: 
\begin{itemize}
  \item variabili proposizionali $A$, $B$, $C$, etc$\ldots$
  \item connettivi $\land$, $\lor$, $\neg$ e $\to$. Il $\neg$ è l'unico
  connettivo unario mentre gli altri sono connettici binari
  \item simboli ausiliari come ``$($'' e ``$)$'' utili a stabilire precedenze
  tra connettivi 
\end{itemize}
Una formula ben formata intuizionistica è definita così:
\begin{enumerate}
  \item ogni variabile proposizionale appartiene alle FBF
  \item se $A$ e $B$ sono FBF allora:
  \begin{itemize}
    \item $\neg A$
    \item $A\lor B$
    \item $A\land B$
    \item $A\to B$
  \end{itemize}
  appartengono alle FBF
  \item nient'altro appartiene alle FBF
\end{enumerate}
E fin qui non si hanno differenze con la logica classica.\\
La differenza rispetto alla logica classica si riscontra nel fatto che i 4
connettivi intuizionistici sono tra loro \textbf{completamente indipendenti}. In
logica classica invece potrei anche solo usare $\neg$ e $\lor$ in quanto gli
altri due si possono ricavare da questi due (tramite leggi di De Morgan
etc$\ldots$). In logica classica $\neg$ e $\lor$ formano un insieme minimale di
operatori. In logica intuizionistica non ho nulla del genere, non posso ridurre
nessun connettivo ad un altro. D'altro canto anche Prolog riduceva pesantemente
il linguaggio, basandosi sulla logica classica e sulle clausole di Horn anche
se si può aprire una discussione in merito al fatto che comunque la riduzione
del linguaggio delle clausole di Horn in Prolog comunque garantisce
l'algoritmicità delle dimostrazioni e la loro costruttività. Le clausole di Horn
sono infatti una restrizione del linguaggio classico e non tutte le formule di
logica classifica sono esprimibili in termini di clausole di Horn e questa è la
motivazione per cui il Prolog di fatto computa.\\
La logica classica pura non è costruttiva in quanto dimostro $A\lor \neg A$
anche se non è detto che poi siamo in grado di dimostrare $A$ o di dimostrare
$\neg A$. Il principio del terzo escluso fa ``saltare'' la costruttività della
logica classica, ``saltando'' la proprietà della disgiunzione DP.\\
Da un punto di vista formale quindi la logica intuizionistica ha l'alfabeto
della logica classica, la definizione di FBF della logica classica ma non si
hanno le equivalenze classiche che permettevano la riduzione del numero di
connettivi.\\ 
Le precedenze sui connettivi sono le stesse di quella logica classica e la
modifica delle precedenze avviene con lo stesso uso delle parentesi della logica
classica. Si ricorda che $\neg$ ha la precedenza su $\land$ che ha precedenza su
$\lor$ che ha precedenza su $\to$.\\
Con il simbolo $\vdash$ indichiamo la \textbf{dimostrabilità}. Quindi la
scrittura $\vdash A$, con $A\in FBF$, indica che la formula $A$ è dimostrabile
nella logica intuizionistica (in teoria bisognerebbe specificare la logica
a pedice di $\vdash$ ma se omesso, salvo diversamente specificato, si parla di
logica intuizionistica).\\
Passiamo quindi a presentare un \textbf{sistema deduttivo} per dimostrare
formule nella logica intuizionistica.\\
Partiamo con un sistema deduttivo molto semplice.\\
L'apparato deduttivo maneggerà due tipi di formule, che indichiamo come
\textbf{formule segnate} dai simboli $T$ e $F$. Data una qualsiasi FBF $A$
allora $TA$ e $FA$ sono formule segnate con $T$ e $F$.\\
Definiamo per ogni connettivo \textbf{T-regole} e \textbf{F-regole}. Suppongo
che $S$ sia un arbitrario insieme di formule segnate, con $/$ che specifica che
la regola si divide in due parti, con $S_T$ specifico che tengo di $S$ solo le
formule segnate con $T$ (sto facendo una \textit{restrizione}):
\begin{table}[H]
  \large
  \centering
  \begin{tabular}{c||c|c}
    connettivo& T-regola& F-regola\\
    \hline
    \hline
    $\land$ & $T\land=\frac{S,T(A\land B)}{S,TA,TB}$&
                        $F\land=\frac{S,F(A\land B)}{S,FA/S,FB}$\\
    \hline
    $\lor$ & $T\lor=\frac{S,T(A\lor B)}{S,TA/S,TB}$&
                        $F\lor=\frac{S,F(A\lor B)}{S,FA,FB}$\\
    \hline
    $\to$ & $T\to=\frac{S,T(A\to B)}{S,FA/S,TB}$&
                        $F\to=\frac{S,F(A\to B)}{S_T,TA,FB}$\\
    \hline
    $\neg$ & $T\neg=\frac{S,T(\neg A)}{S,FA}$&
                        $F\neg=\frac{S,F(\neg A)}{S_T,TA}$\\
    \hline
  \end{tabular}
\end{table}
Senza le due restrizioni di $S$ a $_T$ otterrei i tableaux della logica classica
proposizionale. Quindi passare al questo apparato deduttivo della logica
intuizionistica non è complesso.\\
Usando queste regole una \textbf{dimostrazione} è una sequenze di applicazione
di queste regole che comincia sempre con $FX$ dove $X$ è la formula che voglio
dimostrare e deve terminare con una configurazione, ovvero un insieme di
sotto-dimostrazioni, che contiene una coppia complementare, ovvero una formula
segnata $T$ e la stessa formula segnata $F$. La logica intuizionistica (come 
quella classica) è \textbf{decidibile} quindi con un numero finito di passi
riesco sempre a stabilire se una formula è dimostrabile o meno nella logica
intuizionistica. Nella logica intuizionistica, a differenza di quella classica,
non tutti gli ordini di applicazione delle regole portano ad
una tavola chiusa, ovvero ad una dimostrazione della formula, anche se la
formula è dimostrabile. Esistono strategia di soluzione che non vanno a buon
fine e questo è dovuto all'ordine dell'applicazione delle regole e alla
concorrenza tra l'applicazione di due regole. Le uniche regole che però hanno
questo problema sono le due con restrizione. Non tutti (a priori rispetto
all'ordine di applicazione delle regole) i tableaux quindi sono
chiusi, a differenza della logica classica. 
\begin{esempio}
  Vediamo che il principio del terzo escluso nell'intuizionismo non è
  dimostrabile.\\
  Prendo:
  \[A\lor \neg A\]
  e chiediamoci se è dimostrabile nella logica intuizionistica.\\
  So che non lo è quindi mi aspetto di non trovare un tableaux chiuso, ovvero
  che termina con tutti i rami che contengono una formula segnata $T$ e la stessa
  segnata $F$. Tale formula può essere diversa ramo per ramo.
  %37.49 lezione2
\end{esempio}
\end{document}  
% LocalWords:  clock  Bayesana machine learning Bayes riscalare Prolog Morgan
% LocalWords:  condizionalmente l'algoritmicità
