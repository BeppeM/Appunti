\documentclass[a4paper,12pt, oneside]{book}

%\usepackage{fullpage}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{engrec}
\usepackage{rotating}
\usepackage[safe,extra]{tipa}
\usepackage{showkeys}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{enumerate}
\usepackage{braket}
\usepackage{marginnote}
\usepackage{pgfplots}
\usepackage{cancel}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{algorithmic}
\usepackage{algpseudocode}
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage[cache=false]{minted}

\usepackage{tikz}\usetikzlibrary{er}\tikzset{multi  attribute /.style={attribute ,double  distance =1.5pt}}\tikzset{derived  attribute /.style={attribute ,dashed}}\tikzset{total /.style={double  distance =1.5pt}}\tikzset{every  entity /.style={draw=orange , fill=orange!20}}\tikzset{every  attribute /.style={draw=MediumPurple1, fill=MediumPurple1!20}}\tikzset{every  relationship /.style={draw=Chartreuse2, fill=Chartreuse2!20}}\newcommand{\key}[1]{\underline{#1}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}


\title{Elementi di Bioinformatica}
\author{UniShare\\\\Davide Cozzi\\\href{https://t.me/dlcgold}{@dlcgold}}
\date{}

\pgfplotsset{compat=1.13}
\begin{document}
\maketitle

\definecolor{shadecolor}{gray}{0.80}
\setlist{leftmargin = 2cm}
\newtheorem{teorema}{Teorema}
\newtheorem{definizione}{Definizione}
\newtheorem{esempio}{Esempio}
\newtheorem{corollario}{Corollario}
\newtheorem{lemma}{Lemma}
\newtheorem{osservazione}{Osservazione}
\newtheorem{nota}{Nota}
\newtheorem{esercizio}{Esercizio}
\tableofcontents
\renewcommand{\chaptermark}[1]{%
	\markboth{\chaptername
		\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\chapter{Introduzione}
\textbf{Questi appunti sono presi a lezione. Per quanto sia stata fatta una revisione è altamente probabile (praticamente certo) che possano contenere errori, sia di stampa che di vero e proprio contenuto. Per eventuali proposte di correzione effettuare una pull request. Link: } \url{https://github.com/dlcgold/Appunti}.\\
\textbf{Grazie mille e buono studio!}
\chapter{Introduzione alla Bioinformatica}
Un po' di notazione per le stringhe:
\begin{itemize}
  \item \textbf{simbolo:} $T[i]$
  \item \textbf{stringa:} $T[1]T[2]\ldotst[n]$
  \item \textbf{sottostringa:} $T[i:j]$
  \item \textbf{prefisso:} $T[:j] = T[1:j]$ (inclusi gli estremi)
  \item \textbf{suffisso:} $T[i:] = T[i:|T|]$ (inclusi gli estremi)
  \item \textbf{concatenazione:} $T_1\cdot T_2 = T_1T_2$
\end{itemize}
In bioinformatica si lavora soprattutto con le stringhe, implementando
algoritmi, per esempio, di pattern matching. Nel pattern maching si ha
un testo T come input e un pattern P (solitamente di cardinalità minore
all'input) da ricercare. Si cerca tutte le occorrenze di P in
T. L'algoritmo banale prevede due cicli innestati e ha complessità
$O(nm)$ con $n$ lunghezza di T e $m$ lunghezza di P. Il minimo di
complessità sarebbe $O(n+m)$ (è il \textbf{lower bound}). Si ragiona
anche sulla costante implicita della notazione O-Grande cercando di
capire quale sia effettivamente l'algoritmo migliore con la quantità
di dati che si deve usare. Bisogna quindi bilanciare pratica e teoria.
\section{Bit-Parallel}
È un algoritmo veloce in pratica ma poco performante a livello
teorico, infatti ha complessità $O(nm)$.
\begin{algorithm}
  \For {$i=1\to n$}
  \State $trovato \gets true$
  \For{ $j=1\to m$}
  \If{ $T[1+j-1]<>P[j]$}
  \State $trovato \gets false$
  \EndIf
  \EndFor
  \If{ $trovato$}
  \State $print(i)$
  \EndIf
  \EndFor
\end{algorithm} \\
Questo algoritmo è facilmente eseguibile dall'hardware del pc. \\
In generale si hanno \textbf{algoritmi numerici} che trattano i numeri
e gli \textbf{algoritmi simbolici} che manipolano testi.\\
Si hanno poi gli\textbf{ algoritmi semi-numerici} che trattano i
numeri secondo la loro rappresentazione binaria, manipolando quest'ultima
con \textit{or $\vee$, and $wedge$, xor $\oplus$, left-shift $<<$ e
  right-shift $>>$}. Ricordiamo che il left shift sposta di $k$
posizioni a sinistra i bit, scartandone $k$ in testa e aggiumgendo
altrettanti zeri in coda (lo shift a destra sposta a destra, scarta in
coda e aggiunge zeri in testa). Queste sono operazioni bitwise e sono
mappate direttamente sull'hardware, rendendo tutto estremamente
efficiente.\\
\subsection{Algoritmo D\"om\"olki/Baeza-Yates}
Questo algoritmo viene anche chiamato \textbf{algoritmo shift-and o
  anche bit parallel string matching}.\\
Si definisce una stringa $T$, di cardinalità $n$ in input e un pattern
$P$ di cardinalità $m$.\\
Si costruisce una matrice $M$ \textit{ipotetica}, di dimensione
$n\times m$, con un indice $i$ per $P$ e uno $j$ per $T$  dove:
\[M(i,j)=1\,\,sse\,\,P[:j]=T[j-i+1:j],\,0\leq i\leq m,\,\,0\leq j\leq
  n\]
Quindi $M(i,j)=1$ sse i primi $i$ caratteri del pattern sono uguali
alla sottostring lunga $i$ in posizione $j-i+1$ del testo.\\
Questa matrice è veloce da costruire e si ha:
\[M(m,\cdot) = 1,\,\, M(0,\cdot)=1,\,\, M(\cdot, 0)=0\]
\[M(i,j)=1\,\,sse\,\,M(i=1, j=1)\,\,AND\,\, P[i]=T[j]\]
la prima riga saranno tutti 1 ($ M(0,\cdot)=1$) in quanto la stringa
vuota c'è sempre mentre la prima colonna saranno tutti 0 ($M(\cdot,
0)=0$) in quanto un testo vuoto non matcha mai con una stringa non
vuota.\\
Quindi la matrice avrà 1 solo se i primi caratteri del pattern $P[i]$ sono
uguali alla porzione di testo $=T[j-i+1:j]$. Ma in posizione $M(i-1,
j-1)$ mi accorgo che ho 1 se ho un match anche con un carattere in
meno di P e T. Qindi se $M(i-1,j-1)=0$ lo sarà anche $M(i,j)$. Se
invece $M(i-1,j-1)=1$ devo controllare solo il carattere $P[i]$ e
$T[j]$ e vedere se $ P[i]=T[j]$.
Ovvero, avendo $P=assi$ e $T=apassi$ si avrebbe (omettendo la prima
riga e la prima colonna in quanto banali):
\begin{center}
  \begin{tabular}{c c | c c c c c c}
    & j & 1 & 2 & 3 & 4 & 5 & 6 \\
    i & & a & p & a & s & s & i \\
    \hline
    1 & a & 1 & 0 & 1 & 0 & 0 & 0\\
    2 & s & 0 & 0 & 0 & 1 & 0 & 0 \\
    3 & s & 0 & 0 & 0 & 0 & 1 & 0 \\
    4 & i & 0 & 0 & 0 & 0 & 0 & 1
  \end{tabular}
\end{center}
Con un automa non deterministico che accetta una stringa terminante
con $P$ sarebbe:
\begin{center}
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
    \node[state,initial] (q_0)   {$-1$};
    \node[state] (q_1) [right=of q_0] {$0$};
    \node[state] (q_2) [right=of q_1] {$1$};
    \node[state] (q_3) [right=of q_2] {$2$};
    \node[state, accepting] (q_4) [right=of q_3] {$3$};
    \path[->]
    (q_0) edge  node {a} (q_1)
    edge [loop above] node {$\varepsilon$} ()
    (q_1) edge  node  {s} (q_2)
    (q_2) edge  node  {s} (q_3)
    (q_3) edge  node  {i} (q_4);
  \end{tikzpicture}
\end{center}
La matrice la costruisco con due cicli e controllo solo l'ultima riga
ma il guadagno non si ha a livello di complessità, in quanto sempre
$O(nm)$, ma dall'architettura a 64bit della cpu. Con una word della
cpu posso memorizzare una colonna intera, in quanto vista come numero
binario. Ora lavoro in parallelo su più bit, con un algoritmo
\textbf{bit-parallel}, facendo ogni volta 64 confronti tra binari. In
questo modo crolla la costante moltiplicativa nell'O-grande.\\
Ma come passo da una colonna $C[j]$ a una $C[j-1]$? Con questi step:
\begin{itemize}
  \item la colonna $C[j]$ corrisponde al right shift della colonna $C[j-1]$
  \item aggiungo 1 in prima posizione per compensare lo shift
  \item faccio l'AND con $U[T[j]]$, che è un array binario lungo come
  il pattern dove ho un binario con 1 se è il carattere  di
  riferimento:
  \begin{center}
    P=abca\\
    U[a]=1001\\
    U[b]=0100\\
    U[c]=0010\\
  \end{center}
  \item ragiono sul word size $\omega$ in caso di pattern più grandi
  di 64bit.
\end{itemize}
ottengo:
\begin{center}
 C[j]=((C[j-1])>>1)|(1<<($\omega$-1)\&U[T[j]])
\end{center}
Sapendo una colonna della matrice voglio calcolare la colonna
seguente. Quindi $M[i,j]=M[i-1,j-1]\,\,AND\,\,P[i]=T[j]$ (per
esempio, $M[1,j]=TRUE\,\,AND\,\,(p[i]=T[j])$), cioè conta solo il
confronto dei caratteri. \\
Ogni 1 nell'ultima riga corrisponde ad un'occorrenza.
\\ Però si ha il limite dei 64bit di lunghezza del
pattern e l'uso di più word comporta il riporto sulla colonna
seguente, fattore che si complica all'aumentare della lunghezza del
pattern, soprattutto se arbitraria. Abbiamo inoltre il vantaggio
di non avere branch if/else.
\section{Algoritmo Karp-Rabin}
Vediamo un altro algoritmo di pattern matching che sfrutta una
codifica binaria ma che non sempre risulta corretto ma estremamente
più veloce.\\
Usiamo un alfebto binario e devo fare il match di due stringhe con
ciascuna la sua codifica $H(S)=\sum_{i=1}^{|S|}2^{i-1}H(S[i])$. Mi
muovo sul testo $T$ mediante finestre di ampiezza $m$ pari a quella
del pattern e controllo il fingerprint di quella porzione con quella
del pattern. Inoltre il fingerprint di una finestra è facilmente
calcolabile da quello della precedente. Per farlo elimino il
contributo del carattere della finestra precedente e includere l'unico
aggiunto dalla finestra successiva, in quanto mi sposto di 1:
\[H(T [i + 1 : i + m]) = \frac{H(T [i : i + m - 1]) −T [i]}{2} +
  2^{m-1} T [i + m]\]
Dividendo per due si shifta a destra.\\
La sottostringa è uguale al pattern solo se le fingerprint lo sono:
\[T [i : i + m - 1] = P \Leftrightarrow H(T [i : i + m - 1]) = H(P)\]
\textit{Per estendere la codifica binaria in $k$ caratteri avrò la finestra
  che si sposta di $k$ con la divisione per $k$ anciché per 2.}\\
Si ha il problema della lunghezza del pattern in quanto ho un
$2^{m-1}$ che fa esplodere l'algoritmo in quanto si usa un numero di
bit grandissimo. Si ricorda che un'operazione ``costa 1'' solo se sono
piccoli i numeri in gioco, in questo caso il costo diventa
proporzionale al numero di bit coinvolti. La soluzione di Karp-Rabin è
di continuare con la logica di sopra ma solo con numeri piccoli,
cambiando la definizione di fingerprint prendendo il resto di quanto
sopra con un numero primo $p$:
\[H(T [i + 1 : i + m]) = \left(\frac{H(T [i : i + m - 1]) −T [i]}{2} +
    2^{m-1} T [i + m]\right)\mod p\]
ma in quasto modo la fingerprint non è più iniettiva, più stringhe
avranno la stessa fingerprint e si avranno degli errori. Si ha che
$  2^{m-1} T [i + m]$ viene calcolato iterativamente facendo $\mod p$
ad ogni passo. Si può quindi avere una sottostringa di T con lo stesso
fingerprint del pattern che però non è uguale al pattern,
è un \textbf{falso positivo} ma non si possono avere falsi negativi,
ovvero comunque tutte le occorrenze sono trovate ma si possono
trovare occorrenze false in più:
% capire la formula
\[H(T [i : i + m - 1]) \mod p = H(P) \mod p \Leftarrow T [i : i + m - 1] = P\]
Se il numero primo $p$ è scelto a caso minore di un certo $I$ so che
l'errore è minire di $O(\frac{nm}{I})$.\\
Vogliamo sfruttare però che si hanno solo falsi positivi e provare ad
eseguire l'algoritmo con due $p$ diverse, le vere occorrenze saranno
trovate da entrambe mentre i falsi positivi probabilmente no. Itero
quindi su $k$ numeri primi e il risultato sarà l'intersezione di tutte
le $k$ iterazioni dell'algoritmo, riducendo moltissimo le probabilità di
avere un risultato errato pagando un incremento di un prodotto
$k$ delle operazioni (ma comunque lineare) mentre le chances di errore
diminuiscono esponenzialmente.\\
È quindi un algoritmo probabilistico in quanto i $p$ sono scelti a
caso. Si hanno due categorie di algortimi probabilistici:
\begin{enumerate}
  \item \textbf{Monte Carlo}, come Karp-Rabin, veloci ma non sempre
  corretti
  \item \textbf{Las Vegas}, sempre corretti ma non sempre veloci, come
  ad esempio   nel quicksort con pivot random (dove il meglio è un pivot che è
  l'elemento mediano il peggio è che sia un estremo, che porta
  l'algoritmo ad essere quadratico).
\end{enumerate}
\textit{Posso rendere Karp-Rabin un algoritmo della categoria Las Vegas
controllando tutte le occorrenze (non in questo corso).}\\
% ultima slide non fatta in aula

\end{document}
