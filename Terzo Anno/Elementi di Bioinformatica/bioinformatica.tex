\documentclass[a4paper,12pt, oneside]{book}

%\usepackage{fullpage}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{engrec}
\usepackage{rotating}
\usepackage[safe,extra]{tipa}
\usepackage{showkeys}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{microtype}
\usepackage{enumerate}
\usepackage{braket}
\usepackage{marginnote}
\usepackage{pgfplots}
\usepackage{cancel}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{algorithmic}
\usepackage{algpseudocode}
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage[cache=false]{minted}

\usepackage{tikz}\usetikzlibrary{er}\tikzset{multi  attribute /.style={attribute ,double  distance =1.5pt}}\tikzset{derived  attribute /.style={attribute ,dashed}}\tikzset{total /.style={double  distance =1.5pt}}\tikzset{every  entity /.style={draw=orange , fill=orange!20}}\tikzset{every  attribute /.style={draw=MediumPurple1, fill=MediumPurple1!20}}\tikzset{every  relationship /.style={draw=Chartreuse2, fill=Chartreuse2!20}}\newcommand{\key}[1]{\underline{#1}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[LE,RO]{\slshape \rightmark}
\fancyhead[LO,RE]{\slshape \leftmark}
\fancyfoot[C]{\thepage}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}


\title{Elementi di Bioinformatica}
\author{UniShare\\\\Davide Cozzi\\\href{https://t.me/dlcgold}{@dlcgold}}
\date{}

\pgfplotsset{compat=1.13}
\begin{document}
\maketitle

\definecolor{shadecolor}{gray}{0.80}
\setlist{leftmargin = 2cm}
\newtheorem{teorema}{Teorema}
\newtheorem{definizione}{Definizione}
\newtheorem{esempio}{Esempio}
\newtheorem{corollario}{Corollario}
\newtheorem{lemma}{Lemma}
\newtheorem{osservazione}{Osservazione}
\newtheorem{nota}{Nota}
\newtheorem{esercizio}{Esercizio}
\tableofcontents
\renewcommand{\chaptermark}[1]{%
	\markboth{\chaptername
		\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\chapter{Introduzione}
\textbf{Questi appunti sono presi a lezione. Per quanto sia stata fatta una revisione è altamente probabile (praticamente certo) che possano contenere errori, sia di stampa che di vero e proprio contenuto. Per eventuali proposte di correzione effettuare una pull request. Link: } \url{https://github.com/dlcgold/Appunti}.\\
\textbf{Grazie mille e buono studio!}
\chapter{Introduzione alla Bioinformatica}
Un po' di notazione per le stringhe:
\begin{itemize}
  \item \textbf{simbolo:} $T[i]$
  \item \textbf{stringa:} $T[1]T[2]\ldotst[n]$
  \item \textbf{sottostringa:} $T[i:j]$
  \item \textbf{prefisso:} $T[:j] = T[1:j]$ (inclusi gli estremi)
  \item \textbf{suffisso:} $T[i:] = T[i:|T|]$ (inclusi gli estremi)
  \item \textbf{concatenazione:} $T_1\cdot T_2 = T_1T_2$
\end{itemize}
In bioinformatica si lavora soprattutto con le stringhe, implementando
algoritmi, per esempio, di pattern matching. Nel pattern maching si ha
un testo T come input e un pattern P (solitamente di cardinalità minore
all'input) da ricercare. Si cerca tutte le occorrenze di P in
T. L'algoritmo banale prevede due cicli innestati e ha complessità
$O(nm)$ con $n$ lunghezza di T e $m$ lunghezza di P. Il minimo di
complessità sarebbe $O(n+m)$ (è il \textbf{lower bound}). Si ragiona
anche sulla costante implicita della notazione O-Grande cercando di
capire quale sia effettivamente l'algoritmo migliore con la quantità
di dati che si deve usare. Bisogna quindi bilanciare pratica e teoria.
\section{Bit-Parallel}
È un algoritmo veloce in pratica ma poco performante a livello
teorico, infatti ha complessità $O(nm)$.
\begin{algorithm}
  \For {$i=1\to n$}
  \State $trovato \gets true$
  \For{ $j=1\to m$}
  \If{ $T[1+j-1]<>P[j]$}
  \State $trovato \gets false$
  \EndIf
  \EndFor
  \If{ $trovato$}
  \State $print(i)$
  \EndIf
  \EndFor
\end{algorithm} \\
Questo algoritmo è facilmente eseguibile dall'hardware del pc. \\
In generale si hanno \textbf{algoritmi numerici} che trattano i numeri
e gli \textbf{algoritmi simbolici} che manipolano testi.\\
Si hanno poi gli\textbf{ algoritmi semi-numerici} che trattano i
numeri secondo la loro rappresentazione binaria, manipolando quest'ultima
con \textit{or $\vee$, and $wedge$, xor $\oplus$, left-shift $<<$ e
  right-shift $>>$}. Ricordiamo che il left shift sposta di $k$
posizioni a sinistra i bit, scartandone $k$ in testa e aggiumgendo
altrettanti zeri in coda (lo shift a destra sposta a destra, scarta in
coda e aggiunge zeri in testa). Queste sono operazioni bitwise e sono
mappate direttamente sull'hardware, rendendo tutto estremamente
efficiente.\\
\subsection{Algoritmo D\"om\"olki/Baeza-Yates}
Questo algoritmo viene anche chiamato \textbf{algoritmo shift-and o
  anche bit parallel string matching}.\\
Si definisce una stringa $T$, di cardinalità $n$ in input e un pattern
$P$ di cardinalità $m$.\\
Si costruisce una matrice $M$ \textit{ipotetica}, di dimensione
$n\times m$, con un indice $i$ per $P$ e uno $j$ per $T$  dove:
\[M(i,j)=1\,\,sse\,\,P[:j]=T[j-i+1:j],\,0\leq i\leq m,\,\,0\leq j\leq
  n\]
Quindi $M(i,j)=1$ sse i primi $i$ caratteri del pattern sono uguali
alla sottostring lunga $i$ in posizione $j-i+1$ del testo.\\
Questa matrice è veloce da costruire e si ha:
\[M(m,\cdot) = 1,\,\, M(0,\cdot)=1,\,\, M(\cdot, 0)=0\]
\[M(i,j)=1\,\,sse\,\,M(i=1, j=1)\,\,AND\,\, P[i]=T[j]\]
la prima riga saranno tutti 1 ($ M(0,\cdot)=1$) in quanto la stringa
vuota c'è sempre mentre la prima colonna saranno tutti 0 ($M(\cdot,
0)=0$) in quanto un testo vuoto non matcha mai con una stringa non
vuota.\\
Quindi la matrice avrà 1 solo se i primi caratteri del pattern $P[i]$ sono
uguali alla porzione di testo $=T[j-i+1:j]$. Ma in posizione $M(i-1,
j-1)$ mi accorgo che ho 1 se ho un match anche con un carattere in
meno di P e T. Qindi se $M(i-1,j-1)=0$ lo sarà anche $M(i,j)$. Se
invece $M(i-1,j-1)=1$ devo controllare solo il carattere $P[i]$ e
$T[j]$ e vedere se $ P[i]=T[j]$.
Ovvero, avendo $P=assi$ e $T=apassi$ si avrebbe (omettendo la prima
riga e la prima colonna in quanto banali):
\begin{center}
  \begin{tabular}{c c | c c c c c c}
    & j & 1 & 2 & 3 & 4 & 5 & 6 \\
    i & & a & p & a & s & s & i \\
    \hline
    1 & a & 1 & 0 & 1 & 0 & 0 & 0\\
    2 & s & 0 & 0 & 0 & 1 & 0 & 0 \\
    3 & s & 0 & 0 & 0 & 0 & 1 & 0 \\
    4 & i & 0 & 0 & 0 & 0 & 0 & 1
  \end{tabular}
\end{center}
Con un automa non deterministico che accetta una stringa terminante
con $P$ sarebbe:
\begin{center}
  \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
    \node[state,initial] (q_0)   {$-1$};
    \node[state] (q_1) [right=of q_0] {$0$};
    \node[state] (q_2) [right=of q_1] {$1$};
    \node[state] (q_3) [right=of q_2] {$2$};
    \node[state, accepting] (q_4) [right=of q_3] {$3$};
    \path[->]
    (q_0) edge  node {a} (q_1)
    edge [loop above] node {$\varepsilon$} ()
    (q_1) edge  node  {s} (q_2)
    (q_2) edge  node  {s} (q_3)
    (q_3) edge  node  {i} (q_4);
  \end{tikzpicture}
\end{center}
La matrice la costruisco con due cicli e controllo solo l'ultima riga
ma il guadagno non si ha a livello di complessità, in quanto sempre
$O(nm)$, ma dall'architettura a 64bit della cpu. Con una word della
cpu posso memorizzare una colonna intera, in quanto vista come numero
binario. Ora lavoro in parallelo su più bit, con un algoritmo
\textbf{bit-parallel}, facendo ogni volta 64 confronti tra binari. In
questo modo crolla la costante moltiplicativa nell'O-grande.\\
Ma come passo da una colonna $C[j]$ a una $C[j-1]$? Con questi step:
\begin{itemize}
  \item la colonna $C[j]$ corrisponde al right shift della colonna $C[j-1]$
  \item aggiungo 1 in prima posizione per compensare lo shift
  \item faccio l'AND con $U[T[j]]$, che è un array binario lungo come
  il pattern dove ho un binario con 1 se è il carattere  di
  riferimento:
  \begin{center}
    P=abca\\
    U[a]=1001\\
    U[b]=0100\\
    U[c]=0010\\
  \end{center}
  \item ragiono sul word size $\omega$ in caso di pattern più grandi
  di 64bit.
\end{itemize}
ottengo:
\begin{center}
 C[j]=((C[j-1])>>1)|(1<<($\omega$-1)\&U[T[j]])
\end{center}
Sapendo una colonna della matrice voglio calcolare la colonna
seguente. Quindi $M[i,j]=M[i-1,j-1]\,\,AND\,\,P[i]=T[j]$ (per
esempio, $M[1,j]=TRUE\,\,AND\,\,(p[i]=T[j])$) Cioè conta solo il
confronto dei caratteri. In pratica con lo shift sposto in
basso di uno la colonna e faccio il confronto. \\
Ogni 1 nell'ultima riga corrisponde ad un'occorrenza.
\\ Però si ha il limite dei 64bit di lunghezza del
pattern e l'uso di più word comporta il riporto sulla colonna
seguente, fattore che si complica all'aumentare della lunghezza del
pattern, soprattutto se arbitraria. Abbiamo inoltre il vantaggio
di non avere branch if/else. 
\end{document}
